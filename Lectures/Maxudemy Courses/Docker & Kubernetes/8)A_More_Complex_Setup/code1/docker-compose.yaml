version: '3.8'

services:
  server:
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'
    volumes:
    # Our server, which is the main entry point currently doesn't know anything about our source code.
    # Our interpreter does but that's not enough.The incoming request hits our server first, and it only 
    # forwards requests to PHP files to the PHP interpreter. That means that these PHP files need to be exposed
    # to the server and that simply means that we need to add an extra volume here.

    # we take /var/www/html ifolder because root option in nginx config has root: /var/www/html/public
    # so it is /var/www/html from which we're serving our content and where we are looking for files.
    # Well, of course we're looking in the public folder but that is a folder which exists in the source folder.
      - ./src:/var/www/html
    # And that is a special file which in the end you could say will be merged into a bigger nginx config
    # which is set up inside of the nginx image.
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
    # if we run up just this service dependent services are also up
    depends_on:
      - php
      - mysql

  php:
    # here we cannot just mention the folder because our file is not named as Dockerfile. now we need a more detailed config
    # build : ./dockerfiles

    build:
      context: ./dockerfiles
      dockerfile: php.dockerfile
    volumes:
      # We need to make sure that this php interpreter(this php service) is able to reach our source code. we will have php laravel
      # application source code later, that source code need to be avallaible in path - /var/www/html file inside the container.
      # so we setup bind mount. this laravel source code is generated by utility container


      # by the way,also improve performance a little bit by adding delegated after a colon at the end, that if the containers
      # should write some data there,it's not instantly reflected back to the host machine,instead it is basically processed in
      # batches, you could say,and therefore performance is a bit better.

      # Read only is not an option because it will write some data to our disc. The Laravel framework will also generate
      # some files when it runs,for example the views which are sent back as part of responses.
      - ./src:/var/www/html:delegated
    # By default this image exposes port 9000 internally.so that is what will be exposed by container(we saw this in github page of image)
    # So the container exposes port 9000.in nginx server we send request to port 9000

  mysql:
    platform: linux/x86_64
    image: mysql:5.7
    env_file:
      - ./env/mysql.env
# this is utility container,which will then not only be used internally by Laravel, but which most importantly can be used by us,
# to also set up a Laravel application in the first place.
  composer:
    build:
      context: ./dockerfiles
      dockerfile: composer.dockerfile
  # here we exposeour source code directory to image.so that this image works on our source code directory,
  # and when we use it to install Laravel and set up a Laravel project. so larvel project created by this container,
  # will be avalible inside src folder on our host machine 
    volumes:
      - ./src:/var/www/html
#  it needs PHP to execute code.Artisan is a level command built with PHP.So it needs PHP to do that.
  artisan:
    build:
      context: ./dockerfiles
      dockerfile: composer.dockerfile
    volumes:
      - ./src:/var/www/html
    # You can actually also set certain settings which you set in a docker file normally, inside of a docker-compose file
    # to essentially override the settings inside of the docker file.php container does not need entry point because it
    # just used by nginx to funnel through php files, but now i want to run my own commands so i need a entry point.
    # We could create a separate docker file, but we can also simply add the entry point option here in docker compose.
    # And this allows us to override or add if it doesn't exist yet the entry point in a docker file.
    # here we are executing a file with php,This is a PHP file, but when you execute it it runs a utility program, which can 
    # do a lot of stuff.It's part of the level framework.
    entrypoint: ["php", "/var/www/html/artisan"]

  npm:
    image: node:14
    #  we could either write a docker file to set the working directory and the entry point or we use our newly gained knowledge 
    # that we can add or override certain things here in docker compose
    working_dir: /var/www/html
    entrypoint: ["npm"]
    volumes:
      - ./src:/var/www/html