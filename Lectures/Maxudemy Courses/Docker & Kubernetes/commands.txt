commands -
    1)images -
        1) docker build
            docker build .
            It creates the docker image from docker config file. as argument it takes path of Dockerfile, . means file exist in same
            path where terminal is. this command returns the imageid, which is used to create the container.
            this builds the docker image based on Dockerfile found in this directory. it sets up the image for container to be launched.

            flags -

                a) -t
                    docker build -t goals:latest .

                    this builds a image based on docker configuration and then gives name and tag to that image. so later we can refer to 
                    this image using this name. note here tag is optional you can leave it, if you want. when you print all images, name 
                    of image will be shown in repository column.

        2)docker run "imageId"
            docker run "imageName or tag"
            creates a contianer from image and runs that container in attached mode by default. imageid can exist on system or
                on dockerHub.If it does not exist on system then first it will download the imageId.

            Examples - 

                    docker run node
                        It downloads the node docker image from docker hub(if not found locally) and creates the contianer based 
                        on that image.here container is created and exited automatically because intercative shell created in 
                        container is not exposed to us automatically.for that we can add flag -it, we will actually tell Docker 
                        that we wanna expose an interactive session from inside the container to our hosting machine.

                        docker run -it node

            a)we can specify the command after image name, this will replace the default command that is define in image. see lecture 104

                docker run -it node npm init

            flags -

                1)-p = for attaching port.
                    docker run -p "loalPort":"containerPort" dockerImage
                    it runs the dockerImage into contianer and connect port 3000 of local system with port 80 of docker container.
                2)-d = dettached
                    docker run -d "imageId"
                        for running container in detached mode. it returns the id of detacched container. which can be later used to
                        attach the container.

                    using multiple flags -

                        docker run -p 8000:80 -d "imageid"

                3)-i  interactive
                            docker run -i "imageId"
                                runs docker container from image, and give intercative terminal.generally used along with "t" flag -
                                docker run -it "imageId"


                4)--rm
                    it automatically removes the container when it exists.
                            docker run -p 3000:80 -d --rm "imageId"
                5)--name - gives the naame to container
                    docker run -p 3000:80 -d --rm --name "nameString" "imageId"

                    now we can refer to container using this name, like to stop container - docker stop containerName

                6) -v
                    a)named volumne
                        -v nameofVolume:pathInContainerFileSystem
                        It helps us to create a named volume and linked a local file system with path in container. named volume are not 
                        destroyed when container is removed.but you cannot access the path on your local drive.

                        docker run -p 3000:80 -v feedback:/app/feedback feedback-node:volumes
                    b)bind mount
                        -v "absolutePathInSystem:absolutePathInContainer"
                        docker run -d -p 3000:80  --rm --name feedback-app -v feedback:/app/feedback -v "/Users/susood/Desktop/notes/notes/Lectures/Maxudemy Courses/Docker & Kubernetes/3)Managing_Data_And_Working_With_Volumes/code2/Dockerfile:/app" feedback-node

                        instead of using full absolyte path we can use this -

                            macOS / Linux: -v $(pwd):/app

                            Windows: -v "%cd%":/app

                    c)annonymous volume (see dockerFile of code1 in section 3)
                        -v "absolePathInDockerFileSystem"
                        -v /app/node_modules

                        note - this can also be mentioned in Dockerfile -
                            VOLUME ["/app/node_modules"]

                        Use of annonymous volume, when we want to map floder form local system to docker file system, but some folder
                        on docker system we do not want to overwrite(like node_modules) then we can map this node_module to a announymous
                        volume. now this node_modules will not be overwritten by bind mount.

                    d)ro - by defualt all volumes are read-write tat means docker can read as well as write data into them. but you can turn 
                        them into read only by sing :ro in then end. ex -

                        -v "/Users/susood/Desktop/notes/notes/Lectures/Maxudemy Courses/Docker & Kubernetes/3)Managing_Data_And_Working_With_Volumes/code2/Dockerfile:/app:ro"
                7)--env or -e
                        it lets you pass envirenment varibles. refer lecture 61 in notes to see more ways of adding env variable.

                        -e PORT =8000 -e name=sumit

                8)--env-file
                        lets you pass a file, which contains value of envirement variables.

                        ex - 
                            docker run ---env-file ./.env imageName

                        see lecture 61

                9)--network
                    docker run --network "networkName" imageName
                    network with this names needs to be created there otherwise container creation will faul.see notes of lectures 74 for detals.
        3)docker images
            lists all images

        4)docker rmi "image1Id" "image2Id" "image3Id"
            it removes the image and all its layers. you can only remove the images which are not used by any containers.
            that means even if image is used by container and that container is stopped, first you need to delete the 
            contianer, only then you can remove the image.

        5)docker image prune
            removes all images which are not tagged and not used by any containers.

            flags -
                1)a - removes named (tagged) images also
                    docker image prune -a

        6)docker image inspect "imageId"
            gives the details about a image.

        7)docker tag
            creates the clone of existing image with new tag. but both images will have same imageId

            docker tag "oldTag" "newTag"

        8)docker push "repository name"
            pushes a image to repository in image sharing platform. default is docker hub.


        9)docker pull "repo:tag"
            pulls a image from git hub

    2)containers -

        1)docker ps 
            gives lis of all running docker containers.

            flags -
                a) a -it gives all processes(running and stopped), all containers that docker created for us.
                    docker ps -a


        2)docker stop containerName
            stop the container.you can get docker container name by running docker ps.


        3)docker start "containerName"(or contianerId)
            this restarts a container in detached mode. Note -p is remeber when you first started a container. you cannot give this flag
            while starting container again once it have been stopped.

            flags -
                1)a - attaches the started container.
                    docker start -a "containerName". this is for listening the output, i.e this is listen only mode.if you
                    want to give input, use -i flag.

                2)i - interactive flag.you give input also.
                    docker start -a -i "containerName". you can use -t flag but if orignally container was started with -t flag
                    then that will be memomized.


        4)docker container attach "containerId or ContainerName"
            or 
            docker attach "containerID"
            Attcahes a detacched container.


        5)docker logs "containerName"
            fetches the past logs for containers.

            flags -

                -f - follow. keeps on listening and prints future logs also. we are simply attaching docker gain.

        6)docker rm "container1Name" "container2Name" "container3Name"
            It removes the contianer. this container should be stopped first, you cannot remove a running container.

        7)docker container prune
            removes all stopped containers at once.

        8)docker container inspect "containerName"

            this commands isnpects the container. we used it to get IP address of container where our mongoDB container was running.
            then we used ip address of this container to connect to mongodb from container that was running node code.


        9)docker cp - It allows you to copy files into or from a running container
            docker cp "path1" "path2". copies files form path1 to path2.

            docker path is specified by dockerName:pathInsideDocker
                ex - a)docker cp dummy/. strange_neumann:/test (copies file from local to conatiner. dummy/. means copy all contents 
                    inside dummy, we can also target induival files)

                    b)docker cp strange:/test dummy (copies file from container to local system)

            this is helpful to copy logs files.We will instead learn about a better way of updating code in a container

    3)volumes
        a)docker volume ls
            gives name of all volumes setup by docker. it shows only named and annonymous volumes. bind mounts are not shown.

        b)docker volume rm VOL_NAME
            you get error if you try to remove a volume which is ised by some contianer which is currently running.
        
        
        c)docker volume prune
            removes all unused volume. does not remove volume which is used by currently running containers

        d)docker volume create feedback-files
            it creates a volumne. while giving volume while running container ,docker will create volume if it does not exist. but still you can also
            manually create named volumes.
        e)docker volume inspect "volumeName"

            it shows the details of volumen like when it was created , path  and options used while creating the volume. path is not in local file 
            system, but it path in virtual machine that docker has setup on your system. under options you can see whether this volume is read only or
            not.

    4)network -

        a)docker network create "networkName"
            creates the network

        b)docker network ls

            list the all networks

    5)docker-compose
        for detials on difference between "docker-compose run" and "docker-compose exec". see this link -
            https://medium.com/analytics-vidhya/how-to-understand-the-difference-between-docker-composes-up-vs-run-vs-exec-commands-a506151967df

        a)docker-compose up
            starts the all services and containers mention in docker-compose.yaml. see lecture 96. by default all services are in attached mode.

            another variant -
                a)docker-compose up serviceName
                    this will start only one service

                b)docker-compose up serviceName1 serviceName2 serviceName3
                    this will starts the follwoing services.

            flags -

                a)-d
                    docker-compose up -d
                        starts the all services in container in dettached mode.

                b)--build
                    this forces the images to be rebuild even if nothing has chnaged in file since last time image was rebuild
                    this forces to docker to through dockerFiles again and then recreate the image if something changed.if nothing has chnaged
                    then because of layer concept in images and images are cached , it will not rebuild the image.so it will just reuse the 
                    cached layers.

        b)docker-compose down
            removes all services and removes all containers.deltes all container, default network it created and shuts everything down.
             this does not delete volumes(named volume).

            flags -

                a)-v 
                    docker-compose down -v

                    details - https://docs.docker.com/engine/reference/commandline/compose_down/

        c)docker-compose build
            docker builds the images without starting the containers

        d)docker-compose ps

            list all the services running under container

        e)docker-compose run serviceName 
            varient - docker compose run serviceName command. if you want your container to be destroyed after running the service
                then use --rm flag.

                also this respects the entrypoint mentioned in Dockerfile.

            note - it can be used to just run a single service. optionally you can also give a command that you need to run in container.this comamnd
                will replace the default command in container.this will always spin up a new container.

            Commands you use with run start in new containers with configuration defined by that of the service, including volumes, links,
             and other details. However, there are two important differences:

                a)command passed by run overrides the command defined in the service configuration.
                b)docker compose run command does not create any of the ports specified in the service configuration. This prevents port 
                    collisions with already-open ports. If you do want the service’s ports to be created and mapped to the host, specify
                    the --service-ports -

                        docker compose run --service-ports web python manage.py shell

            docker-compose run is meant for running one-off tasks in a container.by default no ports will be created in case  they collide
             with already opened ports.

            see docs - https://docs.docker.com/engine/reference/commandline/compose_run/

        f)docker-compose exec [options] [-e KEY=VAL...] SERVICE COMMAND [ARGS...]

            docker-compose exec is meant to interact with a container that is already running. That also explains why it requires a 
             COMMAND argument, because it’s expecting the container that is currently running to already be executing the default command
             so it expects to run a different.

            It is best to avoid using docker-compose exec unless there is a strong reason to do so.
            
    6)docker exec "containerName" "command"
        docker exec german npm init
        The Docker exec command allows you to execute certain commands inside of a running container besides the default command, this 
        container executes.So besides the command that might've been specified in a Docker file, that command still continues running.
        So the application still continues to run but you can't run additional commands inside of a container.

        flags -

            a)-it
                docker exec -it containername Command

                use this if you want to stay connected to that process, you're starting up here and if you want to be able to provide input.
