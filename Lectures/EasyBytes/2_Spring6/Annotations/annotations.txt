Form Course -
    1)Defining Beans -
        1)@Bean - @Bean annotation lets Spring know that it needs to call this method when it initializes its context and adds the 
            returned object/value to the Spring context/Spring loC Container.Also returned value is converted into bean.
        3)@Primary - slide 22
        4)@Component - slide 23
        5)@Controller, @Service,@Repository - slide 24
        6)@PostConstruct - slide 27
        7)@PreDestroy -slide 28
        11)@Lazy - slide 53
    2)Configurations -
        1)@Configuration - code 1
            a)Can Have @Bean Method, so this class is passed as argument to Spring Bean to register beans.
            b)Why we use it when we use @ComponentScan -
                a)Manual bean creation: You want fine-grained control over object creation.
                b)External library integration: Third-party classes don’t have @Component, and you can’t add annotations to them.
                c)Conditional Bean Creation Complex bean creation logic that depends on conditions.
                    @Bean
                    @ConditionalOnProperty(name = "app.feature.enabled", havingValue = "true")
                    public FeatureService featureService() {
                        return new FeatureService();
                    }

                    @Bean
                    @Profile("production")
                        public CacheManager cacheManager() {
                        return new RedisCacheManager();
                    }
                d)Configuration Classes can be imported into other configuration classes using @Import.
        2)@ComponentScan
            @ComponentScan(basePackages = {"com.example.implementation","com.example.services"})
            @ComponentScan(basePackageClasses = {com.example.beans.Vehicle.class,com.example.beans.Person.class})
    3)Bean Injection -
        1)@Autowired
        2)@Qualifier - slide 46, specifies the name of bean which should be injected, if more than 1 bean exists for
            given type
        3)@Value - slide 47
    4)Bean Scope
        1)@Scope(BeanDefinition.SCOPE_PROTOTYPE) - slide 50
        2)@Lookup (not covered in course) - when you inject Prototype scoped bean into Singleton scoped bean, you can use @Lookup annotation
         to get new instance of prototype bean every time you refer to it inside singleton bean.
            
            @Lookup // This method will be overridden by Spring to return a new Task instance
            public abstract Task createTask(); // The return type is the prototype bean

    5)AOP -
        1)@EnableAspectJAutoProxy - Slide 63
        2)@Aspect - Defines a aspect
        3)@Before, @AfterReturning, @AfterThrowing, @After, @Around - - Defines the advise (when aspect will be executed).
            It takes pointcut expression as argument
        4)@Order
        5)@PointCut (not covered in course)
        6)Defining annotations - 
            @Retention
            @Target


    6)MVC -
        1)@SpringBootApplication(exclude = ...) -
            1)@SpringBootConfiguration - @Configuration, @Indexed
            2)@EnableAutoConfiguration(exclude = ...) - Enables auto-configuration of Spring application context.
            3)@ComponentScan - Scans for components, configurations, and services in the specified package and its sub-packages.
        2)@Controller - Defines controller in MVC, this will have method which will executed for incoming requests.
        3)@RequestMapping(value={"", "/", "home"}, method = POST) - method inside Controller.
            4)@PostMapping(value ="/abc") - shortcut for @RequestMapping(method = POST)
            4)@GetMapping(value ="/abc")
        5)public ModelAndView saveMessage(@RequestParam String name, @RequestParam)
            This is used to get value from body into method parameter