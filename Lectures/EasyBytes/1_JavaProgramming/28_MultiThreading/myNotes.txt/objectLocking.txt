Monitor Lock
    A monitor lock is a special mechanism that Java uses to control access to a block of code or an object among multiple threads — 
    so that only one thread at a time can execute the critical section associated with that object.

    How it works -
        Every Java object (yes, every Object instance) has an internal monitor that includes:
        A lock flag — to mark whether it’s locked or not.
        Information about which thread owns the lock (if any).
        A wait set — list of threads that are waiting on that object (via wait()).
        This “monitor” is what makes synchronized blocks possible.

Object’s Monitor(Intrinsic Monitor)
    An object’s monitor is a synchronization mechanism attached to every Java object, containing:
        The monitor lock itself (for mutual exclusion),
        A wait set (list of threads waiting via wait()),
        And data structures the JVM uses for managing lock ownership.


        ┌─────────────────────────────────────┐
        │         Object's Monitor            │
        │─────────────────────────────────────│
        │ Lock Owner: Thread A                │
        │ Lock State: Locked                  │
        │ Wait Set: [Thread B, Thread C]      │
        │ Entry Set: [Thread D ]              │
        └─────────────────────────────────────┘

    Note - we also have "Hold Count"

    Code example -

        synchronized (obj) {
            obj.wait();
        }

        here is what happens -

            Thread T1 enters the synchronized block and owns the monitor of obj.
            It calls obj.wait().
            JVM moves T1 to obj’s wait set.
            T1 releases the monitor lock.
            Now another thread (say T2) can acquire the lock on obj.
            When T2 calls obj.notify(), JVM moves one thread (say T1) from the wait set to the entry set.
            When T2 releases the monitor, T1 can reacquire the lock and continue.


Spurious Wake-up - It means that, Even if you never call notify() or notifyAll(), a thread can still wake up from wait().So to ensure correctness, you should always recheck 
    the waiting condition after wait() returns.

    synchronized (obj) {
        while (!condition) {
            obj.wait();
        }
        // safe to proceed
    }

Intrinsic Monitors & Reentrancy
    Reentramt - A reentrant lock means that a thread can acquire the same lock multiple times without getting blocked by itself.
    Java’s intrinsic locks are reentrant, meaning:

        If a thread already holds a monitor, it can re-enter any other synchronized block or method guarded by the same monitor without blocking.
        The JVM maintains a hold count for each monitor per thread.

        First entry → hold count = 1
        Nested entry on same monitor → hold count increments
        Exit → hold count decrements
        When hold count reaches 0 → monitor is released.


synchronized - A synchronized block in Java is a piece of code that allows only one thread at a time to execute it for a given monitor lock (object monitor).
    You can call methods like wait,notify,notifyAll only inside synchonized block because you need access to Object monitor to use these methods and synchonized
    blocks/methods provides access to object monitor of locking object
    Syntax -
        synchronized (lockObject) {
            // critical section code
        }
        lockObject → any non-null Java object
    When a thread enters a synchronized block,
        It must acquire the lock on the specified object (called the monitor lock).
        While it holds that lock, no other thread can enter any synchronized block or method guarded by the same object.
        When the thread exits the block (either normally or via exception), the lock is released automatically.
    How synchronized Works Internally (Step-by-Step)
        Step 1 — Try to acquire the monitor lock
            When the JVM encounters a synchronized (obj):
                It checks whether any other thread currently owns the monitor lock of obj.
                If no one owns it → the current thread acquires the lock and enters the block.
                If another thread owns it → the current thread goes into the BLOCKED state and joins the object’s entry set.

        Step 2 — Execute the critical section -
            Once a thread acquires the lock, it executes the code inside the synchronized block.
            No other thread can enter any synchronized code guarded by the same object’s monitor.
            However, other threads can still execute synchronized blocks on different objects.

        Step 3 — Release the monitor lock
            When the thread exits the synchronized block (even if an exception occurs):
            The JVM automatically releases the monitor lock.
            Then another thread (from the entry set) may acquire the lock and enter.

    What Object Can Be Used as a Lock?

        You can use any non-null Java object as a lock.
        Common choices:
            this → for synchronizing per-instance behavior.
            A private final Object lock = new Object(); → best practice (so external code can’t interfere).
            ClassName.class → for synchronizing static methods or class-wide behavior.
        If you do not mention lock object, these are used as default lock objects -
            a)In instance methods of class, current instance(this) is locked object
            b)Static method: synchronized locks on the Class object.

    Nested Synchronized Locks
        We can have these, so thread will hold locks on multiple objects at same time.IN case the locking object is same, then we already explained
            this condition above.If objects are different then thread will hold locks on different object.If you call lock.wait() inside a synchronized(lock)
            block, the thread releases only that monitor (lock)(most nested one) while waiting. It does not release any other monitors it is holding.




Happens-Before Relationship in Synchronized Blocks

    Exiting a synchronized block on an object establishes a happens-before relationship with any subsequent successful entry 
        into a synchronized block on the same object by another thread.This ensures:

            All changes made inside the first block are flushed to main memory before the lock is released.
            When another thread acquires the same lock, it sees those changes.

    Without this guarantee, threads could see stale values due to CPU caches or compiler reordering.
